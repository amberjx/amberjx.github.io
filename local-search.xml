<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2025/07/31/sort/"/>
    <url>/2025/07/31/sort/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>可以先这么想，</p><ul><li>对于外层循环，就是五个数字要比较四轮（又例如，99个数字比较98轮），n 个数字比较n - 1轮。</li><li>对于内层循环，（以第一次循环的时候为例子）五个数字需要比较四次（才能将最大的那一个沉底），（以第一次循环的时候为例子）99个数字比较98次（才能将最大的那一个沉底）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-comment">//比如说5个数字，就总共比较四轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//比如说5个数字，那么第一轮就比较四次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length - i; j++)&#123;<br>            <span class="hljs-comment">//每一次都会和下面的数字进行比较</span><br>            <span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j + <span class="hljs-number">1</span>];<br>                nums[j + <span class="hljs-number">1</span>] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>新的理解，将下标逐次赋给min_index的时候，并不需要把最后一个（即n - 1）赋给它，因为每次遍历已经将最小值置换到前面去了，最后一个肯定是最大的那一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length, min_index;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">//这里相当于将每一个元素的下标逐个赋给min_index</span><br>        min_index = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">//将每一个元素和自己后面的元素进行比较（i前面的元素一定是每一轮中的最小值）</span><br>            <span class="hljs-keyword">if</span> (arr[min_index] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">//然后记录最小元素的下标</span><br>                min_index = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//通过本轮最小元素的下标将元素置换到前面去（每一轮的i）</span><br>        <span class="hljs-keyword">if</span>(i != min_index)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[min_index];<br>            arr[min_index] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>这个版本的插入排序和希尔排序都挺好记忆的，（对我而言）是最优的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-comment">//可以进行i = 1的优化，但是这个就很刻意了（追求时间复杂度）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i, v = arr[i];<br>        <span class="hljs-comment">//这里只能是arr[j] =arr[--j];只能先减去，后赋值，不能j--</span><br>        <span class="hljs-keyword">while</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j - <span class="hljs-number">1</span>] &gt; v) arr[j] = arr[--j];<br>        arr[j] = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//每次到这里的时候才会/2操作，先判断再除法所以gap = 1的时候，仍然在里面</span><br>        gap /= <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//其实可以将这里优化为 i = gap,因为如果i &lt; gap的话它就会无效遍历</span><br>        <span class="hljs-comment">//可以进行i = gap的优化，但是这个就很刻意了（追求时间复杂度）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">//它将用于在数组中向后查找应该插入v的位置。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j - gap] &gt;= v) &#123;<br>                arr[j] = arr[j - gap];<br>                j -= gap;<br>            &#125;<br>            arr[j] = v;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>是我太无知了，将这个程序Debug了四五次，我还是把这个程序先背过吧，以后多写几遍慢慢理解</p><p>System.arraycopy();中的五个参数分别是：</p><p>源数组，（复制）起始位置，目的数组，（拷贝）起始位置，复制的长度。</p><p><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20240323140042.png" style="zoom:67%;" /><img src="https://kyclnx.oss-cn-hangzhou.aliyuncs.com/kyclnx/20241230110730.png" alt="                                                                      " style="zoom:50%;" />        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    merge_Sort(l, mid);<br>    merge_Sort(mid + <span class="hljs-number">1</span>, r);<br>    merge(l, mid, r);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-keyword">while</span> (l &lt;= m &amp;&amp; j &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span> (arr0[l] &lt;= arr0[j]) arr1[idx] = arr0[l++];<br>        <span class="hljs-keyword">else</span> arr1[idx] = arr0[j++];<br>        idx++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt;= m) arr1[idx++] = arr0[l++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) arr1[idx++] = arr0[j++];<br>    <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> - s &gt;= <span class="hljs-number">0</span>) System.arraycopy(arr1, s, arr0, s, r + <span class="hljs-number">1</span> - s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>它第一次循环下来肯定是左边的数字小于参考值，右边的数全部大于参考值，（参考值就可以完全归位了）</p><ul><li>之前，我一直有一个疑问为啥要<strong>先从</strong>右边找（第一个比tmp小的值）呢？为啥我不可以从左边先找一个比参考值（tmp）大的数字呢</li></ul><p>在进行循环比较的时候，一定是<font color=RED><code>tmp &lt;= arr[j]</code>，</font>如果忘了等于号就会导致从左边到右边第一个数字（也就是tmp）被选中交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l, j = r, tmp = arr[l];<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-comment">//从右边向着左边找一个比tmp小的数字</span><br>        <span class="hljs-keyword">while</span> (tmp &lt;= arr[j] &amp;&amp; j &gt; i) j--;<br>        <span class="hljs-comment">//从左边向着右边找到第一个比tmp大的数字</span><br>        <span class="hljs-keyword">while</span> (tmp &gt;= arr[i] &amp;&amp; j &gt; i) i++;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            arr[i] ^= arr[j];<br>            arr[j] ^= arr[i];<br>            arr[i] ^= arr[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这两句相当于参考值和i,j相遇时候（小于参考值的那一个）进行交换</span><br>    arr[l] = arr[j];<br>    arr[j] = tmp;<br>    <span class="hljs-comment">//其实就是j - 1终结的循环</span><br>    quick_sort(arr, l, j - <span class="hljs-number">1</span>);<br>    quick_sort(arr, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当二者（i,j）相遇之后，那一个数字肯定比参考值小（tmp），才能进行交换操作，使得参考值左边的数字都小于自己，参考值右边的数字都大于自己。</li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3f3f3f3f</span>, max = -min;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> e : arr) &#123;<br>           min = Math.min(min, e);<br>           max = Math.max(max, e);<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">bucketSize</span> <span class="hljs-operator">=</span> (max - min) / arr.length + <span class="hljs-number">1</span>;  <span class="hljs-comment">//根据区间范围和数量确定单个桶范围</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (max - min) / bucketSize + <span class="hljs-number">1</span>;  <span class="hljs-comment">//根据区间范围和单个桶的数量确定需要多少个桶</span><br>       List&lt;Integer&gt;[] lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[bucketCount];<br>       Arrays.setAll(lists, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) &#123;<br>           lists[(e - min) / bucketSize].add(e);  <span class="hljs-comment">//类似于求多少个桶</span><br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> list : lists) list.sort(Comparator.comparing(e -&gt; e));<br>       <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : lists[i])<br>               arr[idx++] = e;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>不能处理负数,如果有负数就得加偏移量。</p><p>有一些像我之前写过的统计字符串中的字符那一道题目，应该也是10个中最简单的一个了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">1000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) &#123;<br>            <span class="hljs-keyword">if</span> (array[e] == <span class="hljs-literal">null</span>) array[e] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> array[e] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> array[i];<br>                <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>) arr[idx++] = i;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>核心思想: 用0~9表示位上面的数,总共10个桶,遍历maxLen次,每次遍历当前位,将每个数放到自己值的位置。时间复杂度稳定O(k * n),不能处理负数,如果有负数就得加偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    LinkedList&lt;Integer&gt;[] lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>[<span class="hljs-number">10</span>];<br>    Arrays.setAll(lists, e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());  <span class="hljs-comment">//这里使用linkedList比较好,使用linkedlist方便删除</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) maxLen = Math.max(getLength(e), maxLen);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxLen; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e : arr) lists[getIndexValue(i, e)].add(e);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> list : lists) &#123;<br>            <span class="hljs-keyword">while</span> (!list.isEmpty()) &#123;<br>                arr[idx++] = list.poll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>            num /= <span class="hljs-number">10</span>;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getIndexValue</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res = num % <span class="hljs-number">10</span>;<br>            num /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/07/28/hello-world/"/>
    <url>/2025/07/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
